---
title: "Macroinvertebrate Data Analysis"
author: "Marney Pratt"
date: "March 8, 2024"
format: pdf
---

## Getting Setup

Before getting started, it is a good practice to start with a clean slate by restarting your R session

Go to the top menu, select Session then select Restart R

Keep all of your analysis in this same .qmd file and keep all the associated files in the project folder. Make sure the project name is showing in the upper right of the RStudio window.


# Load packages

```{r setup}

library(tidyverse) ## for readr, dplyr, ggplot2
library(vegan) ## for calculating diversity measures (you can remove this if you are not calculating diversity measures)
library(ggbeeswarm) ## for jittering points
library(flextable) ## for making formatted tables

```

# Import Data

Figure out which data file(s) you need to import. Find the code you need in the "importing_data" folder within the "script_templates" folder. Copy and paste the code you need in the chunk below.

```{r import data}

env <- read_csv("data/env.csv",
               col_types = cols(date = col_date(format = "%Y-%m-%d"),
                
                location = col_factor(levels = c(
                  "Downstream","Upstream")), 
                
                season = col_factor(levels = c("Summer","Fall")), 
                
                year = col_factor()
               )) 

macros <- read_csv("data/macros.csv",
                 col_types = cols(date = col_date(format = "%Y-%m-%d"),
                  
                  location = col_factor(levels = c(
                    "Downstream","Upstream")), 
                  
                  season = col_factor(levels = c("Summer","Fall")), 
                  
                  year = col_factor()
                 )) 


master.taxa <- read_csv("data/master.taxa.csv") |> 
  distinct()


waterQ <- read_csv("data/waterQ.csv",
                 col_types = cols(date = col_date(format = "%Y-%m-%d"),
                  
                  location = col_factor(levels = c(
                    "Downstream","Upstream")), 
                  
                  season = col_factor(levels = c("Summer","Fall")), 
                  
                  year = col_factor()
                 )) 


```

# Data Wrangling

Find the code you need to prepare or "wrangle" your data to make any calculations needed and combine any datasets you need to combine by looking in the "data_wrangling" folder within the "script_templates" folder. Copy and paste the code you need in the chunk below.

Note, once you have completed this code chunk, you should have a new data frame that has ONE value per sampleID. You will then use this new data frame going forward.

```{r}
#| label: limpet density wrangling


# make sure the 'tidyverse' package is installed and loaded to run the code below

# macros and master.taxa data files must be imported before you can run the code below

#calculate density for each sampleID
density.df <- macros |> 
  
  #join taxa info
  left_join(master.taxa) |>
  
  # Summarize for each sampleID and each genus 
  group_by(sampleID, genus) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, genus,
           fill = list(density = 0)) |> 
  
  #filter for genus of interest 
  #this needs to match what is in the macros file
  #replace this blank with the genus you want to keep
  filter(genus == "Ferrissia")

#get sample info and env variables of interest
variables <- macros |>
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                wTemp) |> 
  distinct()

#add sample info back to density data
my.df <- left_join(density.df, variables) |> 
  
  #filter out anything you don't want
  #the example below would filter out just the year 2018
  dplyr::filter(year != "2018")


# this code will make a scatter plot 
# if you do not want a line of best fit, then delete the geom_smooth() line

ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = wTemp,       #put the factor on the x-axis
      y = density + 1)) +       #continuous variable = y

  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #add best fit line
  geom_smooth(method = "lm", se = FALSE) + 

  #nicer labels (see axis.labels.R script)
  xlab("Water Temperature ("~degree~"C)") +
  ylab(bquote("Limpet Density (number/"~m^2*")")) +

  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l")  # adds log-scale tick marks


```
```{r}
#| label: limpets and flathead mayflies sediment redistribution

# make sure the 'tidyverse' package is installed and loaded to run the code below
# macros, master.taxa, & env data must all be imported before you can run the code below


##calculate the number of macros in each sampleID
macro.total <- macros |> 
  
  #calculate the number of macros in each sampleID
  group_by(sampleID, benthicArea) |> 
  summarize(total.macros = sum(number, na.rm = TRUE))



##calculate the number of each taxon of interest in each sampleID
macro.family <- macros |> 
  
  #join taxonomic information 
  left_join(master.taxa) |> 
  
  # Summarize for each sampleID and each family 
  # note you can exchange family with another taxonomic level of interest
  group_by(sampleID, family, FFG) |> 
  dplyr::summarise(number = sum(number, na.rm = TRUE)) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, family, FFG,
           fill = list(number = 0)) |> 
  
  #filter for families of interest
  #this needs to match what is in the macros file
  #replace thses blanks with the families you want to keep
  ## note you can exchange family with another taxonomic level of interest
  dplyr::filter(family == "Ancylidae" | family == "Heptageniidae",
                FFG == "scr")  



##join the two datasets
macro.joined  <- left_join(macro.total, macro.family) |> 
  
  #calc the relative abundance of each taxon
  # replace the blanks with the name of each taxon
  mutate(relab = number/total.macros,
         density = number/benthicArea)


## select other variables you want present in your final dataset
variables <- macros |> 
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                DO, wTemp) |> 
  distinct()

##add in the variables just selected
#sampleID is the "key" used to match up the two data frames
my.df <- left_join(macro.joined, variables) 


#this code will make a dot plot with median and all points included
#make sure you have loaded the ggbeeswarm package to use geom_quasirandom()

my.df |> 
  filter(family == "Ancylidae") |> 

ggplot(
  
  #set the aesthetics
  aes(x = year,       #put 1st factor on x-axis
      y = density + 1,       #continuous variable = y
      group = location, color = location)) + #2nd factor as group & color
  
  #adds quasirandom jittered points
  geom_quasirandom(
    shape = 19,            #shape as circle
    size = 2,              #size of point
    alpha = 0.8,           #transparency
    width = 0.2,          #spread
    dodge.width = 0.8,       #match with position_dodge(width = )
    show.legend = TRUE) +  #creates key
  
  #adds median
  stat_summary(
    fun = median,       #graphs the median
    geom = "crossbar",  #crossbar shape
    width = 0.5,        #width of the bar
    linewidth = 0.75,   #thickness of bar
    color = "black",    #color 
    position = position_dodge(width = 0.8), #match to dodge.width above
    show.legend = FALSE) +   #removes extra key
  
  #nicer labels (see axis.labels.R script)
  ylab(bquote("Density + 1 (number/"~m^2*")")) +
  xlab("Year") +
  labs(color = "Location") + #label for the color key
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") +  # adds log-scale tick marks
  
  facet_grid(cols = vars(season))   #place factor to split by facets here



# this plot will show the difference in the median density
# downstream - upstream with year and location as factors
# the horizontal red line at zero shows no difference between locations
# above the red line means more downstream, below means more upstream
# the vertical blue line shows when winter sediment redistribution began
# note the y-axis is on a pseudo-log scale to be able to handle negative and 0

#get median macro density for each year, season, location 
mac.sum <- my.df |> 
  group_by(year, season, location, family) |> 
  summarize(median.loc = median(density)) |> 
  na.omit()

#pivot wider then subtract locations
mac.diff <- mac.sum |> 
  pivot_wider(names_from = location, values_from = median.loc) |> 
  mutate(median.diff = (Downstream - Upstream))

mac.diff |> 
  filter(family == "Ancylidae") |> 
  ggplot(aes(
    x = year,
    y = median.diff)) +
  geom_hline(yintercept = 0, color = "red", size = 2, alpha = 0.25) +
  geom_point(size = 3) +
  ylab("Median Difference in Density (#/m\u00b2)\n (Downstream - Upstream)") +
  xlab("Year") +
  theme_classic(base_size = 14) +
  facet_grid(cols = vars(season)) +
  scale_y_continuous(breaks = c(-10^(4:0), 0, 10^(0:4)),
                     transform = "pseudo_log",
                     limits = c(-4000, 4000)) +
  guides(y = guide_axis_logticks(negative_small = 1)) +
  geom_vline(xintercept=2.5, color = "blue", size = 2, alpha = 0.25)



```


```{r}

# make sure the 'tidyverse' package is installed and loaded 
# macros, master.taxa, and env data files must be imported before you 
# can run the code below

#get sample info
sample.info <- macros |>
  select(date, sampleID, season, year, location, benthicArea) |> 
  distinct()

#get total samples
samples <- macros |>
  select(sampleID) |> 
  distinct()


#select env variable(s) you want by replacing the blank with the column name(s)
env.vars <- env |> 
  select(sampleID, turb)


#calculate density for each sampleID
tolerant.density <- macros |> 
  
  #join taxa info
  left_join(master.taxa) |>
  
  #filter for tolerant macros (8-10)
 dplyr::filter(tolerance >= 8) |> 
  
  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise(density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |> 
  
  #add back the sampling info
  left_join(sample.info) |> 
  
  #add env variables
  left_join(env.vars)



#calculate density for each sampleID
sensitive.density <- macros |> 
  
  #join taxa info
  left_join(master.taxa) |>
  
  #filter for sensitive macros (0-3) 
  dplyr::filter(tolerance <= 3) |> 
  
  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |> 
  
  #add back the sampling info
  left_join(sample.info) |> 
  
  #add env variables
  left_join(env.vars)


#calculate density for each sampleID
moderate.density <- macros |> 
  
  #join taxa info
  left_join(master.taxa) |>
  
  #filter for sensitive macros (0-3) 
  dplyr::filter(tolerance > 3, tolerance < 8) |> 
  
  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |> 
  
  #add back the sampling info
  left_join(sample.info) |> 
  
  #add env variables
  left_join(env.vars)


```
```{r}
#calculate density for each sampleID
density.df <- macros |> 
  
  #join taxa info
  left_join(master.taxa) |>
  
  # Summarize for each sampleID and each genus 
  group_by(sampleID, genus) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 
  # 
  # #fill in group combos where there were none present with zeros
  # ungroup() |> 
  # complete(sampleID, genus,
  #          fill = list(density = 0)) |> 
  
  #filter for genus of interest (this needs to match what is in the macros file)
  filter(genus == "Stenonema" | genus == "Maccaffertium") #replace this blank with the genus you want to keep

#get sample info
sample.info <- macros |>
  select(date, sampleID, season, year, location, benthicArea) |> 
  distinct()

#add sample info back to density data
density.df <- left_join(density.df, sample.info)


ggplot(
  data = density.df,   #put the data frame name here
  aes(x = year,               #1st factor=x
      y = log(density + 1), , #continuous variable=y,
      fill = location, color = location)) +   #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  #ylab("___") +
  #xlab("___") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=16) +
  theme(legend.position = "top") + #change the position of the key as needed
  facet_wrap(vars(season))   #3rd factor here


```



```{r}
macro.df <-  macros |> 
  
  #join taxa info
  left_join(master.taxa)

```


```{r data wrangling}

#calculate limpet density for each sampleID
limpet.density <- macros |> 
  
  #join taxa info
  left_join(., master.taxa) |>
  
  # Summarize for each sampleID and each family 
  # change group_by function to remove or add grouping variables as needed 
  # if you want a specific group of organisms, add that column name into 
  # the list of grouping variables (family, organism_aggr, FFG, etc)
  # then filter for the organism or group you want
  group_by(sampleID, family) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 

  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, family,
           fill = list(density = 0)) |> 
  
  #filter for limpets
  filter(family == "Ancylidae")

#get sample info
sample.info <- macros |>
  select(date, sampleID, season, year, location, benthicArea) |> 
  distinct()

#add sample info back to density data
limpet.density <- left_join(limpet.density, sample.info)


#select desired variables from env
env2 <- env |> 
  select(date, sampleID, season, year, location, 
         depth, per_rock, pH, DO, wTemp, light, flow,
         mon.precip, mon.ADD) 

#add env variables to density data
limpet.df <- left_join(limpet.density, env2) 


```



```{r family density}

#calculate limpet density for each sampleID
family.density <- macros |> 
  
  #join taxa info
  left_join(., master.taxa) |>
  
  # Summarize for each sampleID and each family 
  # change group_by function to remove or add grouping variables as needed 
  # if you want a specific group of organisms, add that column name into 
  # the list of grouping variables (family, organism_aggr, FFG, etc)
  # then filter for the organism or group you want
  group_by(sampleID, family, FFG) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 
  
  filter(FFG == "cg")

family.density.test <- family.density |> 

  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) 
  
#get sample info
sample.info <- macros |>
  select(date, sampleID, season, year, location, benthicArea) |> 
  distinct()






```

```{r}
#| label: scraper family diversity

# make sure the `vegan` and 'tidyverse' packages are installed and loaded to run the code below

# macros and master.taxa data files must both be imported before you can run the code below

# remove missing values, and make sure each taxon is summarized within sampleID
macro.long <- macros |>  
  
  #join taxa info
  left_join(., master.taxa) |>
  
  dplyr::filter(!is.na(invDens), FFG == "cf", year !="2018") |> 
  dplyr::select(sampleID, family, invDens) |> 
  group_by(sampleID, family) |> 
  dplyr::summarise(density = sum(invDens))


# convert to wide format
macro.wide <- macro.long |> 
  pivot_wider(names_from = family, 
              values_from = density,
              values_fill = list(density = 0),
              values_fn = list(density = sum)) |>
  tibble::column_to_rownames("sampleID")


#Calculate diversity index values

#Shannon
H <- diversity(macro.wide)


#effective number of species
effective.sp <- exp(H)


#Richness
rich <- specnumber(macro.wide) 

#Max possible diversity
max.H <- log(rich)


#Pielou's Evenness J 
J <- H / max.H

#put all diversity values into a single data frame
macro.div <- data.frame(H, effective.sp, rich, max.H, J) |> 
  tibble::rownames_to_column("sampleID")


# select other variables you want present in your final dataset
variables <- macros |> 
  
  #add or remove any variables from the original dataset that you want present
  #make sure you keep sampleID because this is what is used to match the data
  select(sampleID, date, location, year, season, benthicArea) |> 
  distinct() 
  

#this script takes the macro.div and joins it with the mydf one we just created
#sampleID is the "key" used to match up the two data frames
macro.div <- left_join(macro.div, variables) 
  






```

```{r}
#| label: density by tolerance


# make sure the 'tidyverse' package is installed and loaded 
# macros and master.taxa data files must be imported before you 
# can run the code below

#get sample info
sample.info <- macros |>
  select(date, sampleID, season, year, location, benthicArea) |> 
  distinct()

#get total samples
samples <- macros |>
  select(sampleID) |> 
  distinct()


#select env variables you want
env.vars <- env |> 
  select(sampleID, mon.median.wTemp)


#calculate density for each sampleID
tolerant.density <- macros |> 
  
  #join taxa info
  left_join(., master.taxa) |>
  
  #filter for tolerant macros 
  dplyr::filter(tolerance >= 7) |> 
  
  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(., samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |> 
  
  #add back the sampling info
  left_join(., sample.info) |> 

  #add env variables
  left_join(., env.vars)



```

```{r}
#| label: density by moderate


# make sure the 'tidyverse' package is installed and loaded 
# macros and master.taxa data files must be imported before you 
# can run the code below

#get sample info
sample.info <- macros |>
  select(date, sampleID, season, year, location, benthicArea) |> 
  distinct()

#get total samples
samples <- macros |>
  select(sampleID) |> 
  distinct()


#select env variables you want
env.vars <- env |> 
  select(sampleID, mon.median.wTemp)


#calculate density for each sampleID
moderate.density <- macros |> 
  
  #join taxa info
  left_join(., master.taxa) |>
  
  #filter for tolerant macros 
  dplyr::filter(tolerance > 3, tolerance < 7) |>

  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(., samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |> 
  
  #add back the sampling info
  left_join(., sample.info) |> 

  #add env variables
  left_join(., env.vars)



```

```{r}
#| label: density by sensitive


# make sure the 'tidyverse' package is installed and loaded 
# macros and master.taxa data files must be imported before you 
# can run the code below

#get sample info
sample.info <- macros |>
  select(date, sampleID, season, year, location, benthicArea) |> 
  distinct()

#get total samples
samples <- macros |>
  select(sampleID) |> 
  distinct()


#select env variables you want
env.vars <- env |> 
  select(sampleID, mon.median.wTemp)


#calculate density for each sampleID
sensitive.density <- macros |> 
  
  #join taxa info
  left_join(., master.taxa) |>
  
  #filter for tolerant macros 
  dplyr::filter(tolerance <= 3) |>

  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(., samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |> 
  
  #add back the sampling info
  left_join(., sample.info) |> 

  #add env variables
  left_join(., env.vars)



```

```{r}
#| label: density by three tolerance levels

# make sure the 'tidyverse' package is installed and loaded 
# macros and  master.taxa files must be imported before you 
# can run the code below

#get sample info
sample.info <- macros  |> 
  select(date, sampleID, season, year, location, benthicArea) |>
  distinct()

#get total samples
samples <- macros |>
  select(sampleID) |>
  distinct()


#calculate density for each sampleID
tolerant.density <- macros |> 
  
  #join taxa info
  left_join (master.taxa) |>
  
  #filter for tolerant macros (8-10)
  dplyr::filter(tolerance >= 8) |> 
  
  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |>
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |>  
  
  #add tolerant label
  mutate(tolerance = "tolerant")  
  
  
#calculate density for each sampleID
moderate.density <- macros |> 
  
  #join taxa info
  left_join (master.taxa) |>
  
  #filter for moderately tolerant macros (4-7) 
  dplyr::filter(tolerance > 3, tolerance < 8) |> 
  
  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |>
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |>  
  
  #add tolerant label
  mutate(tolerance = "moderate") 



#calculate density for each sampleID
sensitive.density <- macros |> 
  
  #join taxa info
  left_join (master.taxa) |>
  
  #filter for sensitive macros (0-3) 
  dplyr::filter(tolerance <= 3) |> 
  
  # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(sampleID) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |>
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |>  
  
  #add tolerant label
  mutate(tolerance = "sensitive")


#join three tolerance datasets together
tol.df <- bind_rows(sensitive.density, moderate.density) |> 
          bind_rows(tolerant.density) |> 
  
  
  #add back the sampling info
  left_join(sample.info) |> 
  
  #filter out fall data and just keep summer
  filter(season == "Summer") |> 
  
  #make tolerance a factor and put the levels in the right order
  mutate(tolerance = factor(tolerance, levels = c("sensitive", "moderate", "tolerant")))


  


```
```{r}
#| label: graph by three tolerance levels


ggplot(
  data = tol.df,   #put the data frame name here
  aes(x = year, y = density+1,                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  ylab(bquote("Density + 1 (number/"~m^2*")")) +
  xlab("Year") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=12) +
  theme(legend.position = "top") + #change the position of the key as needed
  facet_wrap(vars(tolerance))  + #3rd factor here 
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") # adds log-scale tick marks to the left axis

```
```{r}


#calculate density for each sampleID
tdens <- macros |> 
  
    
  #filter out fall data and just keep summer
  filter(season == "Summer") |> 
  
  #join taxa info
  left_join (master.taxa) |>
  
   # Sum for each sampleID  
  # density of filtered macroinvertebrates
  # change group_by function to remove or add grouping variables as needed 
  group_by(family, tolerance) |> 
  dplyr::summarise (density = sum(invDens, na.rm = TRUE)) |>
  
  #fill in group combos where there were none present with zeros
  ungroup() 

```

```{r}


# make sure the 'tidyverse' package is installed and loaded to run the code below

# macros and master.taxa data must both be imported before you can run the code below

# select other variables you want present in your final dataset
variables <- macros |> 
  
  #join environmental variables
  left_join(env) |> 
  
  #add or remove any variables from the original dataset that you want present
  #make sure you keep sampleID because this is what is used to match the data
  select(sampleID, date, location, year, season, benthicArea, 
         mon.median.turb, mon.max.turb, turb) |> 
  distinct()


#this code will calculate the substrate stability ratio (SSR)
# SSR = (#scrapers + #collector filterers)/(#collector gatherers + shredders)

macro.t <- macros |> 
  
  #join taxonomic information 
  left_join(master.taxa) |> 
  
  #calculate the number of each FFG in each sampleID
  group_by(sampleID) |> 
  summarize(total = sum(number, na.rm=TRUE))

macro.ssr <- macros |> 
  
  #join taxonomic information 
  left_join(master.taxa) |> 
  
  #calculate the number of each FFG in each sampleID
  group_by(sampleID, FFG) |> 
  summarize(number = sum(number, na.rm=TRUE)) |> 
  
  #pivot wider to make column for each FFG
  pivot_wider(names_from = FFG, values_from = number, values_fill=0) %>% 
  
  #calc number of macros that like rocks
  #calc number of macros that like sand
  #calc substrate stability ratio
  mutate(rock = sum(scr,cf, na.rm=TRUE),
         sand = sum(cg,sh, na.rm=TRUE),
    ssr = ((sum(scr,cf, na.rm=TRUE)+1)/(sum(cg,sh, na.rm=TRUE)+1))) |> 
  
  #add total of all macros
  left_join(macro.t ) |> 
  
  #calc the relative abundance of macros that like rocks and sand
  mutate(relab.rock = rock/total,
         relab.sand = sand/total) |> 
  
  #add other variables back
  left_join(variables, by="sampleID") |> 
  
  #calc the density of macros that like rocks and sand
  mutate(den.rock = rock/benthicArea,
         den.sand = sand/benthicArea)
  



ggplot(
  data = macro.ssr, 
  aes(x = turb, y = relab.sand, color = location)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  labs(color = "Location") +
  theme_classic(base_size = 18) +
  theme(legend.position = "top") 


ggplot(
  data = macro.ssr,   #put the data frame name here
  aes(x = year, y = relab.sand,                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  ylab("Relative Abundance of \n Macroinvertebrates that Prefer Sand") +
  #xlab("___") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=14) +
  theme(legend.position = "top") + #change the position of the key as needed
  facet_wrap(vars(season))   #3rd factor here

ggplot(
  data = macro.ssr,   #put the data frame name here
  aes(x = year, y = (den.sand+1),                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  ylab("Density of Macroinvertebrates \n that Prefer Sand") +
  xlab("Year") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=14) +
  theme(legend.position = "top") + #change the position of the key as needed
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks to the left axis
  facet_wrap(vars(season))   #3rd factor here


ggplot(
  data = macro.ssr,   #put the data frame name here
  aes(x = location, y = relab.rock,                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6, show.legend = FALSE) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  ylab("Relative Abundance of \n Macroinvertebrates that Prefer Rock") +
  xlab("Location") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=14) +
  #theme(legend.position = "top") + #change the position of the key as needed
  facet_wrap(vars(season))   #3rd factor here

macro.ssr |> 
  filter(season == "Summer") |> 
ggplot(
     #put the data frame name here
  aes(x = year, y = log(den.rock+1),                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6, show.legend = FALSE) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  #ylab("Turbidity (NTU)") +
  xlab("Location") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=14) 
  #theme(legend.position = "top") + #change the position of the key as needed
  #facet_wrap(vars(year))   #3rd factor here


```
```{r}
#| label: diversity


# make sure the `vegan` and 'tidyverse' packages are installed and loaded to run the code below

# macros and master.taxa data files must both be imported before you can run the code below

# remove missing values, and make sure each taxon is summarized within sampleID
macro.long <- macros |>  
  
  #join taxa info
  left_join(master.taxa) |>
  
  #diversity for mix of taxa (organism_aggr)
  #change organism_aggr to family or other taxonomic unit if desired
  dplyr::filter(!is.na(invDens), year !="2018") |> 
  dplyr::select(sampleID, organism_aggr, invDens) |> 
  group_by(sampleID, organism_aggr) |> 
  dplyr::summarise(density = sum(invDens))


# convert to wide format
macro.wide <- macro.long |> 
  pivot_wider(names_from = organism_aggr, 
              values_from = density,
              values_fill = list(density = 0),
              values_fn = list(density = sum)) |>
  tibble::column_to_rownames("sampleID")


#Calculate diversity index values

#Shannon index (H)
shannon <- diversity(macro.wide)


#effective number of species
effective.sp <- exp(shannon)


#Richness
richness <- specnumber(macro.wide) 

#Max possible diversity
max.H <- log(richness)


#Pielou's Evenness J 
evenness <- shannon / max.H

#put all diversity values into a single data frame
macro.div <- data.frame(shannon, effective.sp, richness, max.H, evenness) |> 
  tibble::rownames_to_column("sampleID")


# select other variables you want present in your final dataset
variables <- macros |> 
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                mon.median.wTemp, mon.max.wTemp, wTemp) |> 
  distinct()

#add in the variables just selected
#sampleID is the "key" used to match up the two data frames
my.df <- left_join(macro.div, variables) 


# this code will make a scatter plot with a curve
# 
ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.wTemp,       #put the factor on the x-axis
      y = shannon)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(aes(color = season), size = 3) +    #sets the size of the points
  
  #add locally weighted smoothing curve
  geom_smooth(method = "loess",       
              se = FALSE, 
              formula = y ~ x) + 
  
  #nicer labels (see axis.labels.R script)
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") + #label for the color key
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top")   #controls legend/key

ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.wTemp,       #put the factor on the x-axis
      y = evenness,       #continuous variable = y
      color = season)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #add best fit line
  geom_smooth(method = "lm", se = FALSE) + 

  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top")



```

```{r}
#| label: sensitive macros by precip


# make sure the 'tidyverse' package is installed and loaded 
# macros, master.taxa, and env data files must be imported before you 
# can run the code below

#get total samples
samples <- macros |>
  select(sampleID) |> 
  distinct()

#calculate density for each sampleID
sensitive.density <- macros |> 
  
  #join taxa & tolerance info
  left_join(master.taxa) |>
  
  #filter for sensitive macros (0-3) 
  dplyr::filter(tolerance <= 3) |>
  
  #filter out the midges
  dplyr::filter(family != "Chironomidae") |> 
  
  # Summarize for each sampleID 
  # density of ALL macroinvertebrates
  group_by(sampleID)  |>  
  dplyr::summarise(density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |>
  
  mutate(tolerance = "sensitive")
  

#get sample info and env variables of interest
variables <- macros |>
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                mon.precip) |> 
  distinct()

#add sample info back to density data
my.df <- left_join(sensitive.density, variables) |> 
  
  #filter out anything you don't want
  #the example below would filter out just the year 2018
  dplyr::filter(year != "2018")



```

```{r}
#| label: CF CG by precip


# make sure the 'tidyverse' package is installed and loaded 
# macros, master.taxa, and env data files must be imported before you 
# can run the code below

#get total samples
samples <- macros |>
  select(sampleID) |> 
  distinct()

#calculate density for each sampleID
cf.density <- macros |> 
  
  #join taxa & tolerance info
  left_join(master.taxa) |>
  
  #filter for FFG
  dplyr::filter(FFG == "cf") |>
  
  #filter out the midges
  dplyr::filter(family != "Chironomidae") |> 
  
  # Summarize for each sampleID 
  # density of ALL macroinvertebrates
  group_by(sampleID)  |>  
  dplyr::summarise(density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |>
  
  mutate(FFG = "filterers")
  

#get sample info and env variables of interest
variables <- macros |>
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                mon.precip) |> 
  distinct()

#calculate density for each sampleID
cg.density <- macros |> 
  
  #join taxa & tolerance info
  left_join(master.taxa) |>
  
  #filter for FFG 
  dplyr::filter(FFG == "cg") |>
  
  #filter out the midges
  dplyr::filter(family != "Chironomidae") |> 
  
  # Summarize for each sampleID 
  # density of ALL macroinvertebrates
  group_by(sampleID)  |>  
  dplyr::summarise(density = sum(invDens, na.rm = TRUE)) |> 
  
  #add back in samples that had none present
  right_join(samples) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID,  
           fill = list(density = 0)) |>
  
  mutate(FFG = "gatherers")

#add sample info back to density data
my.df <- bind_rows(cf.density, cg.density) |> 
  left_join(variables) 

# this code will make a scatter plot with a curve
# 
ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.precip,       #put the factor on the x-axis
      y = density +1,       #continuous variable = y
      color = FFG)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 2, alpha = 0.6) +    #sets the size of the points
  
  #add locally weighted smoothing curve
  geom_smooth(method = "loess",
              se = FALSE,
              formula = y ~ x) +
  
  #nicer labels (see axis.labels.R script)
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") + #label for the color key
  
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  facet_wrap(vars(FFG, season))   #place factor to split by facets here

#see the resources below for some additional options to make a nice scatter plot 
# https://www.datanovia.com/en/lessons/ggplot-scatter-plot/
# https://ggplot2.tidyverse.org/index.html

#see the links below for more on smoothing curves using geom_smooth
# https://www.sharpsightlabs.com/blog/geom_smooth/ 
# https://blogs.bgsu.edu/math6820ywonkye/2018/10/25/loess/
# https://en.wikipedia.org/wiki/Local_regression

```


# Data Description


Make a formatted table of the data that you used in your analysis to include in the Data Analysis Methods section of your paper.

```{r table of data used}

table.sum <- limpet.df |> 
  
  #summarize by date, year, season, location (to get number of microhabs sampled per date)
  group_by(date, year, season, location) |> 
    summarize(
      area = sum(benthicArea),
      mon.ADD = mean(mon.ADD, na.rm=TRUE),
      mon.precip = mean(mon.precip, na.rm=TRUE),
      samples = n()
    ) |> 
  
  #change date to month/day
  mutate(date = format(as.Date(date), '%m/%d')) |> 


  #summarize by year, season, location 
  group_by(year, season, location) |> 
    summarize(
      dates = str_c(date, collapse = ", "),
      samples = sum(samples),
      area = sum(area),
      mon.ADD = round(mean(mon.ADD, na.rm=TRUE), digits=0),
      mon.precip = round(mean(mon.precip, na.rm=TRUE), digits=0)
    )  
  

#create the formatted
ft <- flextable(table.sum)

#create header labels
ft <- set_header_labels(ft,
                        year = "Year",
                        season = "Season",
                        location = "Location",
                        dates = "Dates",
                        samples = "# of Samples",
                        area = "Total Area Sampled (m^2)",
                        mon.ADD = "Monthly ADD",
                        mon.precip = "Monthly Precipitation (mm)"
                        )


#bold the headings
ft <- bold(ft, part="header")

ft <- merge_v(ft, j = ~ year + season)

#set table properties
ft <- set_table_properties(ft, layout = "autofit", width = 1)

#center columns
ft <- align(ft, align = "center", part = "all" )


#add lines between year x season
ft <- theme_vanilla(ft) |> 
  fontsize(size = 10)

ft <- fix_border_issues(ft)

#print table
ft



#see https://davidgohel.github.io/flextable/ for more information and formatting options

```


## Weather Table

This is optional, but if you want to have a summary of what the weather was like in the month before sampling, then use the two code chunks below along with the template code from "script_templates" then "data_description" and select the correct version of the "weather_table\_.R" script based on which factors you are using and paste that code below. (note that the weather is the same for both locations, so you do not need that factor)

```{r}
#| label: weather table
#| tbl-cap: Unformatted Weather Table
#| message: false
#| warning: false

#before you run this code, make sure your dataframe has all the necessary columns
#you need season, year, location, mon.ADD, mon.precip

weather.sum <- density.df |>  #put the name of your wrangled data here
    group_by(season, year) |> 
  summarize(
    mon.ADD = round(mean(mon.ADD, na.rm=TRUE), digits=0),
    mon.precip = round(mean(mon.precip, na.rm=TRUE), digits=0)
  )  

weather.sum

```

If you want code to make a formatted table for you, go to the "data_description" script templates and select the 'formatted_weather_table\_.R' script based on which factors you are using and paste that code below. (note that the weather is the same for both locations, so you do not need that factor)

```{r}
#| label: formatted weather table
#| tbl-cap: Weather Table
#| include: true

#To get a formatted table, make sure that the {flextable} package is loaded
#If you want to format the table yourself, then don't use this code

#see https://davidgohel.github.io/flextable/ for more information and formatting options

#create the formatted table
ft <- flextable(weather.sum)

#create header labels
ft <- set_header_labels(ft,
                        season = "Season",
                        year = "Year",
                        mon.ADD = "Monthly Accumulated Degree Days",
                        mon.precip = "Monthly Total Precipitation (mm)"
                        )

#bold the headings
ft <- bold(ft, part="header")

ft <- merge_v(ft, j = ~ season + year)

#set table properties
ft <- set_table_properties(ft, layout = "autofit", width = 1)

#add lines between year x season
ft <- theme_vanilla(ft) |> 
  fontsize(size = 10)

#center columns
ft <- align(ft, align = "center", part = "all" )

ft <- fix_border_issues(ft)

#print the table
#right click on the table, choose select all, 
#choose copy, then paste in your document
#finish formatting as needed in your document
ft


```

Use the template code below to calculate the descriptive statistics for your variable of interest. The output of this code should not all be reported in your paper. Decide which (if any) of the descriptive statistics you should report and make sure to round the values. Descriptive statistics can be reported in the text of the results (see this example results section) if relatively simple, or you can make a formatted table of just the necessary, rounded values to include in your paper (in which case you might want to use "formatted_descriptiveStats_table.R" in the "data_description" script templates to help you make a formatted table).

```{r descriptive stats}

# the code below will calculate descriptive statistics for a variable of interest grouped by another variable

density.sum <- limpet.df |> # put the name of the data frame here
  filter(!is.na(density)) |> # remove missing values from the variable of interest
  group_by(season, year, location) |> # put the name of the grouping variable(s) here
  summarize(mean = mean(density), # put the name of the variable you want to summarize in this & following blanks
            median = median(density), 
            SD = sd(density), 
            IQR = IQR(density), 
            min = min(density),
            max = max(density),
            N = n())

density.sum


DO.sum <- limpet.df |> # put the name of the data frame here
  filter(!is.na(DO)) |> # remove missing values from the variable of interest
  group_by(season, year, location) |> # put the name of the grouping variable(s) here
  summarize(mean = mean(DO), # put the name of the variable you want to summarize in this & following blanks
            median = median(DO), 
            SD = sd(DO), 
            IQR = IQR(DO), 
            min = min(DO),
            max = max(DO),
            N = n())
DO.sum

```



# Data Visualization

Find the code you need to visualize (=graph) your data by looking in the "graphing" folder within the "script_templates" folder. Copy and paste the code you need in the chunk below.



```{r}

limpet.df |> 
 # filter(season == "Fall") |> 

ggplot(
  data = .,   #put the data frame name here
  aes(x = location, y = log(density+1),                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.2, #play with these values as needed
    dodge.width = 1,  show.legend = FALSE) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=1), #match this width to dodge.width above
               show.legend = FALSE) + 
  ylab(bquote("Log Density +1 (number/"~m^2*")")) +
  xlab("Location") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=16) +
  facet_wrap(vars(season))   #3rd factor here


```

```{r}

limpet.df |> 
ggplot(
  data = ., 
  aes(x = DO, y = density+1, color = location)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(method = "lm", se = FALSE) + #adds line of best fit
  ylab(bquote("Log Density + 1 (number/"~m^2*")")) +
  xlab("Dissolved Oxygen (mg/L)") +
  labs(color = "Location") +
  theme_classic(base_size = 16) +
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks to the left axis 
  facet_wrap(vars(season)) 

  
```

```{r}



# this code will make a dot plot with median and all points included
# make sure you have loaded the ggbeeswarm package to use geom_quasirandom()
# alternatively, you can use geom_jitter() instead

density.df |> 

ggplot(
  data = .,   #put the data frame name here
  aes(x = year, y = density+1,                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  ylab(bquote("Limpet Density (number/"~m^2*")")) +
  xlab("Year") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=16) +
  facet_wrap(vars(season)) +  #3rd factor here
  theme(legend.position = "top") +
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") # adds log-scale tick marks to the left axis


#see the resources below for some additional options to make a nice plot 
# https://www.datanovia.com/en/lessons/ggplot-dot-plot/
# https://ggplot2.tidyverse.org/index.html

```

```{r}

ggplot(
  data = density.df, #put the data frame name here
  aes(x = year, y = density+1,                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color 
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.7) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.7), #match this width to dodge.width above
               show.legend = FALSE) + 
  ylab(bquote("Limpet Density (number/"~m^2*")")) +
  xlab("Year") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=16)  +
  theme(legend.position = "top") +
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") # adds log-scale tick marks to the left axis



```


```{r}

ggplot(
  data = density.df, #put the data frame name here
  aes(x = year, y = density+1,                 #1st factor = x, continuous variable = y,
      fill = year, color = year)) +       #2nd factor = fill & color 
  geom_quasirandom(
    shape=21, size=3, alpha = 0.75, width=0.3) +
  stat_summary(fun = median, fun.min = median, fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.75, color = "black") +
  ylab(bquote("Limpet Density (number/"~m^2*")")) +
  xlab("Year") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=16)  +
  theme(legend.position = "none") +
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") # adds log-scale tick marks to the left axis



```

To save your graph with the `ggsave()` function, you need to name the resulting file with surrounding " ", and indicate the size via height, width, and units. Don't forget to save the graph with a dpi call between 300-500 to make it nice and crisp! Look at the `ggsave()` help file for more information and options.

```{r Save your graph, eval = F}

# save the graph!
ggsave(filename="limpet3factor.png",  #recommended to use.png or .jpg file types
       height = 5, width = 8, units = "in", 
       dpi = 300)

```


```{r stacked graphs density}

#data wrangling for macro density
macro.den.ffg <- macros |> 
    left_join(., master.taxa) |> 
  group_by(sampleID, FFG) |> 
  dplyr::summarise (ffgDens = sum(invDens, na.rm = TRUE)) |> 
  ungroup |>
    complete(sampleID, FFG, fill = list(ffgDens = 0)) 

macro.ffg.na <- macro.den.ffg |> 
    filter(is.na(FFG) & ffgDens > 0)

variables <- macros |> 
    select(sampleID, date, location, year, season) |> 
    distinct()

macro.den.ffg <- macro.den.ffg |> 
    filter(!is.na(FFG)) |> 
    bind_rows(macro.ffg.na) |> 
    left_join(., variables)


#descriptives
dens.sum <- macro.den.ffg |> # put the name of the data frame here
  filter(!is.na(ffgDens)) |> # remove missing values from the variable of interest
  group_by(location, year, season, FFG) |> # put the name of the grouping variable(s) here
  summarize(mean = mean(ffgDens), # put the name of the variable you want to summarize in this & following blanks
            median = median(ffgDens), 
            sum(ffgDens),
            SD = sd(ffgDens), 
            IQR = IQR(ffgDens), 
            min = min(ffgDens),
            max = max(ffgDens),
            n())
dens.sum

#write_csv(dens.sum, "dens.sum.csv")

# density proportion
ggplot(
  data=macro.den.ffg, # put the data frame here
  aes(x=year,y=ffgDens, fill = FFG))+ #put 1st factor as x 
  geom_bar(position = "fill", stat="identity")+
  ylab("Proportion\n") +
  scale_fill_discrete(name="Functional Feeding Groups",
                      labels=c("collector filterers", "collector gatherers",
                               "predators", "scrapers", "shredders" ))+
  coord_cartesian(ylim=c(0,1), expand=FALSE, clip='off') +
  theme_classic(base_size=10) +
  facet_grid(rows=vars(season), cols=vars(location)) 


```

```{r}


#data wrangling for macro relative abundance
macro.ffg <- macros |> 
  left_join(., master.taxa) |> 
    group_by(sampleID, FFG) |> 
    dplyr::summarise (num.ffg = sum(number, na.rm = TRUE)) |> 
    ungroup |>
    complete(sampleID, FFG, fill = list(num.ffg = 0)) 

macro.sample <- macros |>  #replace blank with the same data frame name from above
    group_by(sampleID) |> 
    dplyr::summarise (total.num = sum(number, na.rm = TRUE))

macro.ffg <- left_join(macro.ffg, macro.sample, by = "sampleID") |> 
   mutate(macro.ffg, relab=num.ffg/total.num) 
  
macro.ffg.na <- macro.ffg |> 
    filter(is.na(FFG) & relab > 0)
  
variables <- macros |> 
    select(sampleID, date, location, year, season) |> 
    distinct()

macro.ffg <- macro.ffg |> 
    filter(!is.na(FFG)) |> 
    bind_rows(macro.ffg.na) |> 
    left_join(., variables)


#descriptives
rel.sum <- macro.ffg |> # put the name of the data frame here
  filter(!is.na(relab)) |> # remove missing values from the variable of interest
  group_by(location, year, season, FFG) |> # put the name of the grouping variable(s) here
  summarize(mean = mean(relab), # put the name of the variable you want to summarize in this & following blanks
            median = median(relab), 
            sum(relab),
            SD = sd(relab), 
            IQR = IQR(relab), 
            min = min(relab),
            max = max(relab),
            n())
rel.sum

#write_csv(rel.sum, "rel.sum.csv")

# relative abundance proportion
ggplot(
  data=macro.ffg, # put the data frame here
  aes(x=year,y=relab, fill = FFG))+ #put 1st factor as x 
  geom_bar(position = "fill", stat="identity")+
  ylab("Relative Abundance\n") +
  scale_fill_discrete(name="Functional Feeding Groups",
                      labels=c("collector filterers", "collector gatherers",
                               "predators", "scrapers", "shredders" ))+
  coord_cartesian(ylim=c(0,1), expand=FALSE, clip='off') +
  theme_classic(base_size=10) +
  facet_grid(rows=vars(season), cols=vars(location)) 


```


```{r richness}


ggplot(
  data = macro.div, 
  aes(x = DO, y = rich, color = location)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) +
  facet_wrap(vars(season))   #3rd factor here



ggplot(
  data = macro.div, 
  aes(x = wTemp, y = rich, color = location)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) +
  facet_wrap(vars(season))   #3rd factor here


ggplot(
  data = macro.div, 
  aes(x = pH, y = rich, color=location)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) 
  #facet_wrap(vars(season))   #3rd factor here



ggplot(
  data = macro.div, #put the data frame name here
  aes(x = location, y = DO, fill=location)) + #1st factor = x, continuous variable = y, 2nd factor = fill
  geom_boxplot(position=position_dodge(width=1), #adjust as needed
               width=0.3, alpha=0.25,      #adjust these values as needed
               outlier.shape= NA,         #remove outliers when all the points are included
               show.legend = FALSE) +       
  geom_quasirandom(aes(color=location),                    #2nd factor to match fill above
                   dodge.width=1, width=0.25,         #dodge.width here must match position_dodge(width= )
                   shape=21, size=1, alpha = 0.5) +   #sets the size, shape, and transparency of the points
  stat_summary(fun=mean, geom="point",                #adds mean with an X
               position=position_dodge(width=1),      #must match position_dodge(width= ) for boxplot
               shape=4, size=1, colour="black", stroke=1,  #adjust as needed
               show.legend = FALSE) + 
  #ylab("___") +
  #xlab("___") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=16)  +
  theme(legend.position = "top") +
  facet_wrap(vars(season))   #3rd factor here


```



```{r shannon}


ggplot(
  data = macro.div, 
  aes(x = DO, y = H, color = location)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) +
  facet_wrap(vars(season))   #3rd factor here



ggplot(
  data = macro.div, 
  aes(x = wTemp, y = H, color = location)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) +
  facet_wrap(vars(season))   #3rd factor here


ggplot(
  data = macro.div, 
  aes(x = pH, y = H, color = location)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) +
  facet_wrap(vars(season))   #3rd factor here



```

```{r}
#| label: tolerant vs wTemp


tolerant.density |> 
  filter(!is.na(median.wTemp), location == "Downstream") |> 


ggplot(
  data = ., 
  aes(x = median.wTemp, y = density+1, color = season)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(aes(x = median.wTemp, y = density+1), color = "black", 
              method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) +
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") # adds log-scale tick marks to the left axis

```
```{r}
#| label: moderate vs wTemp


moderate.density |> 
  filter(!is.na(median.wTemp), location == "Downstream") |> 


ggplot(
  data = ., 
  aes(x = median.wTemp, y = density+1, color = season)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(aes(x = median.wTemp, y = density+1), color = "black", 
              method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) +
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") # adds log-scale tick marks to the left axis

```

```{r}
#| label: sensitive vs wTemp


sensitive.density |> 
  filter(!is.na(median.wTemp), location == "Downstream") |> 


ggplot(
  data = ., 
  aes(x = median.wTemp, y = density+1, color = season)) + 
  geom_point(size = 3) +                   #play with the point attributes as needed
  geom_smooth(aes(x = median.wTemp, y = density+1), color = "black", 
              method = "lm", se = FALSE) + #adds line of best fit
  #ylab("___") +
  #xlab("___") +
  #labs(color = "___") +
  theme_classic(base_size = 18) +
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") # adds log-scale tick marks to the left axis

```


```{r}

env |> 

ggplot(
  data =.,   #put the data frame name here
  aes(x = year, y = pH,                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  #ylab("___") +
  #xlab("___") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=16) +
  theme(legend.position = "top") + #change the position of the key as needed
 # scale_y_log10() +     #changes y-axis to log-scale
  #annotation_logticks(sides = "l") + # adds log-scale tick marks to the left axis
  facet_wrap(vars(season))   #3rd factor here


```

```{r}

env |> 

ggplot(
  data =.,   #put the data frame name here
  aes(x = year, y = turb,                 #1st factor = x, continuous variable = y,
      fill = location, color = location)) +       #2nd factor = fill & color
  geom_quasirandom( 
    shape=21, size=2, alpha = 0.5, width=0.1, #play with these values as needed
    dodge.width = 0.6) + #adjust the dodge width as needed
  stat_summary(fun = median, 
               fun.min = median, 
               fun.max = median, #change median to mean if desired
               geom = "crossbar", na.rm = TRUE,
               width = 0.5, size = 0.5, #play with these values as needed
               color = "black",
               position=position_dodge(width=0.6), #match this width to dodge.width above
               show.legend = FALSE) + 
  #ylab("___") +
  #xlab("___") +
  coord_cartesian(expand=TRUE) +
  theme_classic(base_size=16) +
  theme(legend.position = "top") + #change the position of the key as needed
  facet_wrap(vars(season))   #3rd factor here

```

```{r}
#| label: wTemp by location

# make sure the 'tidyverse' package is installed and loaded 
# the waterQ data file must be imported before you 
# can run the code below

my.df <- waterQ |> 
  
  #replace the blank below with the water quality variable(s) of interest
  dplyr::select(date, sampleID, season, year, location, 
                wTemp) |> 
  
  #filter out any missing values
  na.omit() |> 
  
  #filter out anything you don't want
  #the example below would filter out just the year 2018
  dplyr::filter(year != "2018")

#this code will make a violin + boxplot + points 
#with the sample size on the x-axis
#make sure you have loaded the ggbeeswarm package to use geom_quasirandom()

# first calculate the sample size
sample_size = my.df  |>  #put the data frame name here
  group_by(location)  |>    #factor here
  summarize(num = n()) #don't change anything here

#ggplot with sample sizes added
my.df  |>    #put the same data frame name here as above
  
  #joins the dataframe with sample size information
  left_join(sample_size, by = "location")  |>  #same factor as group_by above
  
  #makes new column with sample size below each x-axis value
  mutate(
    myaxis = paste0(location, "\n", "n=", num)) |> #same factor as group_by above
  
  ggplot(
    
    #set the aesthetics
    aes(x = myaxis,    #put column created with sample size info
        y = wTemp,       #continuous variable = y
        fill = location)) + #same factor as group_by above
  
  #adds violin plot
  geom_violin(
    width = 0.5,     #spread
    alpha = 0.2) +   #transparency
  
  #adds boxplots
  geom_boxplot(width = 0.1,           #width
               alpha = 0.8,           #transparency
               color = "black",       #color of outline
               outlier.shape = NA) +  #removes outliers
  
  #adds quasirandom jittered points
  geom_quasirandom(aes(color = location), #same factor as x and fill
                   shape = 21,       #shape as open circle
                   size = 1,         #size
                   alpha = 0.5,      #transparency
                   width = 0.25) +   #spread
  #adds mean
  stat_summary(fun = mean,      #graphs the mean
               geom = "point",  #single point for mean
               shape = 4,       #shape as X if 4
               size = 2,        #size
               color = "black", #color
               stroke = 1) +    #line thickness
  
  #nicer labels (see axis.labels.R script)
  ylab("Water Temperature ("~degree~"C)") +
  xlab("Location") +
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "none")   #controls legend/key

#see the resources below for some additional options to make a nice plot 
# https://www.datanovia.com/en/lessons/ggplot-violin-plot/
# https://ggplot2.tidyverse.org/index.html



```

```{r}

#| label: mon.median.wTemp by location

my.df <- env |> 
  
  #replace the blank below with the water quality variable(s) of interest
  dplyr::select(date, sampleID, season, year, location, 
                mon.max.wTemp, mon.median.wTemp, wTemp) |> 
  
  #filter out any missing values
  na.omit()  



# first calculate the sample size
sample_size = my.df  |>  #put the data frame name here
  group_by(season)  |>    #factor here
  summarize(num = n()) #don't change anything here

#ggplot with sample sizes added
my.df  |>    #put the same data frame name here as above
  
  #joins the dataframe with sample size information
  left_join(sample_size, by = "season")  |>  #same factor as group_by above
  
  #makes new column with sample size below each x-axis value
  mutate(
    myaxis = paste0(season, "\n", "n=", num)) |> #same factor as group_by above
  
  ggplot(
    
    #set the aesthetics
    aes(x = myaxis,    #put column created with sample size info
        y = wTemp,       #continuous variable = y
        fill = season)) + #same factor as group_by above
  
  #adds violin plot
  geom_violin(
    width = 0.5,     #spread
    alpha = 0.2) +   #transparency
  
  #adds boxplots
  geom_boxplot(width = 0.1,           #width
               alpha = 0.8,           #transparency
               color = "black",       #color of outline
               outlier.shape = NA) +  #removes outliers
  
  #adds quasirandom jittered points
  geom_quasirandom(aes(color = season), #same factor as x and fill
                   shape = 21,       #shape as open circle
                   size = 1,         #size
                   alpha = 0.5,      #transparency
                   width = 0.25) +   #spread
  #adds mean
  stat_summary(fun = mean,      #graphs the mean
               geom = "point",  #single point for mean
               shape = 4,       #shape as X if 4
               size = 2,        #size
               color = "black", #color
               stroke = 1) +    #line thickness
  
  #nicer labels (see axis.labels.R script)
  ylab("Monthly Median Water Temperature ("~degree~"C)") +
  xlab("Season") +
  
  scale_x_discrete(limits = rev) +
  
  #additional formatting
  theme_classic(base_size = 14)  +  #sets the font size
  theme(legend.position = "none")   #controls legend/key


```

```{r}

#| label: richness by waterQ


# make sure the `vegan` and 'tidyverse' packages are installed and loaded to run the code below

# macros and master.taxa data files must both be imported before you can run the code below

# remove missing values, and make sure each taxon is summarized within sampleID
macro.long <- macros |>  
  
  #join taxa info
  left_join(master.taxa) |>
  
  #diversity for mix of taxa (organism_aggr)
  #change organism_aggr to family or other taxonomic unit if desired
  dplyr::filter(!is.na(invDens), year !="2018") |> 
  dplyr::select(sampleID, family, invDens) |> 
  group_by(sampleID, family) |> 
  dplyr::summarise(density = sum(invDens))


# convert to wide format
macro.wide <- macro.long |> 
  pivot_wider(names_from = family, 
              values_from = density,
              values_fill = list(density = 0),
              values_fn = list(density = sum)) |>
  tibble::column_to_rownames("sampleID")


#Calculate diversity index values

#Shannon index (H)
shannon <- diversity(macro.wide)


#effective number of species
effective.sp <- exp(shannon)


#Richness
richness <- specnumber(macro.wide) 

#Max possible diversity
max.H <- log(richness)


#Pielou's Evenness J 
evenness <- shannon / max.H

#put all diversity values into a single data frame
macro.div <- data.frame(shannon, effective.sp, richness, max.H, evenness) |> 
  tibble::rownames_to_column("sampleID")


# select other variables you want present in your final dataset
variables <- macros |> 
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                mon.precip, wTemp, mon.median.wTemp, light, mon.median.discharge, mon.median.turb) |> 
  distinct()

#add in the variables just selected
#sampleID is the "key" used to match up the two data frames
my.df <- left_join(macro.div, variables)



ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.precip,       #put the factor on the x-axis
      y = richness,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  facet_wrap(vars(season))   


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.wTemp,       #put the factor on the x-axis
      y = richness,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  facet_wrap(vars(season))


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.discharge,       #put the factor on the x-axis
      y = richness,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  facet_wrap(vars(season))   

ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = wTemp,       #put the factor on the x-axis
      y = richness,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  facet_wrap(vars(season))


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = light,       #put the factor on the x-axis
      y = richness,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  scale_x_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "b") + # adds log-scale tick marks
  facet_wrap(vars(season))


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.turb,       #put the factor on the x-axis
      y = richness,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  scale_x_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "b") + # adds log-scale tick marks
  facet_wrap(vars(season))
```


```{r}
#| label: neophylax Glossosomatidae vs DO



# make sure the 'tidyverse' package is installed and loaded to run the code below

# macros, env, and master.taxa data files must be imported before you can run the code below

#calculate density for each sampleID
density.t <- macros |> 
  
  #join taxa info
  left_join(master.taxa) |>
  
  # Summarize for each sampleID and each family 
  group_by(sampleID, family) |> 
  dplyr::summarise(density = sum(invDens, na.rm = TRUE)) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, family,
           fill = list(density = 0)) |> 
  
  #filter for family of interest 
  #this needs to match what is in the macros file
  #replace this blank with the family you want to keep
  dplyr::filter(family == "Thremmatidae")  |> 
  
  mutate(family = "Thremmatidae")

#calculate density for each sampleID
density.g <- macros |> 
  
  #join taxa info
  left_join(master.taxa) |>
  
  # Summarize for each sampleID and each family 
  group_by(sampleID, family) |> 
  dplyr::summarise(density = sum(invDens, na.rm = TRUE)) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, family,
           fill = list(density = 0)) |> 
  
  #filter for family of interest 
  #this needs to match what is in the macros file
  #replace this blank with the family you want to keep
  dplyr::filter(family == "Glossosomatidae") |> 
  
  mutate(family = "Glossosomatidae")

#get sample info and env variables of interest
variables <- macros |>
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                DO, pH, mon.median.wTemp, mon.precip) |> 
  distinct()

#add sample info back to density data
my.df <- bind_rows(density.t, density.g) |> 
  left_join(variables) |> 
  
  filter(season == "Summer") 

ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = DO,       #put the factor on the x-axis
      y = density +1,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  facet_wrap(vars(family))

ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = pH,       #put the factor on the x-axis
      y = density +1,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  facet_wrap(vars(family))

ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.wTemp,       #put the factor on the x-axis
      y = density +1,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  facet_wrap(vars(family))

ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.precip,       #put the factor on the x-axis
      y = density +1,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  facet_wrap(vars(family))


#pivot for competition

my.df2 <- my.df |> 

  #pivot wider to make column for each FFG
  pivot_wider(names_from = family, values_from = density, values_fill=0) |> 
  filter(season == "Summer")

ggplot(
  data = my.df2, #put the data frame name here
  
  #set the aesthetics
  aes(x = Glossosomatidae +1,       #put the factor on the x-axis
      y = Thremmatidae +1,       #continuous variable = y
      color = year)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(size = 3) +    #sets the size of the points
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key

  scale_y_log10() +     #changes y-axis to log-scale
  scale_x_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "lb") + # adds log-scale tick marks
  facet_wrap(vars(year))



#this code will make stacked bar graphs for 
#relative abundance of families

ggplot(
data = my.df, #put the data frame name here

#set the aesthetics
aes(x = year,       #put the factor on the x-axis
    y = density,       #proportion values = y
    fill = family, color = family)) + 
  
  #adds stacked bars
  geom_bar(position = "fill", stat = "identity") +
  

  #nicer labels (see axis.labels.R script)
  xlab("Year") +
  ylab("Relative Abundance\n") +

  
  #remove repeated key
  guides(color = FALSE) +
  
  #additional formatting
  coord_cartesian(ylim = c(0,1), expand = FALSE, clip = 'off') +
  theme_classic(base_size = 12)  +  #sets the font size
  theme(legend.position = "right")   #controls legend/key

  #you can use the line below to split by factors
  #(season, year, location, or other factors)
  #facet_grid(rows = vars(____), cols = vars(____)) 

#see the resources below for some additional options to make a nice plot 
# https://www.r-graph-gallery.com/48-grouped-barplot-with-ggplot2.html
# https://ggplot2.tidyverse.org/index.html
# https://r-charts.com/part-whole/stacked-bar-chart-ggplot2/

```



```{r}
#| label: competition-wide

# make sure the 'tidyverse' package is installed and loaded to run the code below
# macros, master.taxa, & env data must all be imported before you can run the code below


##calculate the number of macros in each sampleID
macro.total <- macros |> 
  
  #calculate the number of macros in each sampleID
  group_by(sampleID, benthicArea) |> 
  summarize(total.macros = sum(number, na.rm = TRUE))



##calculate the number of each taxon of interest in each sampleID
macro.family <- macros |> 
  
  #join taxonomic information 
  left_join(master.taxa) |> 
  
  # Summarize for each sampleID and each family 
  # note you can exchange family with another taxonomic level of interest
  group_by(sampleID, family) |> 
  dplyr::summarise(number = sum(number, na.rm = TRUE)) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, family,
           fill = list(number = 0)) |> 
  
  #filter for first family of interest
  #this needs to match what is in the macros file
  #replace this blank with the family you want to keep
  ## note you can exchange family with another taxonomic level of interest
  dplyr::filter(family == "Thremmatidae" | family == "Glossosomatidae")  



##join the two datasets
macro.joined  <- left_join(macro.total, macro.family) |> 
  
  #calc the relative abundance of each taxon
  # replace the blanks with the name of each taxon
  mutate(relab = number/total.macros,
         density = number/benthicArea)
  
  
## select other variables you want present in your final dataset
variables <- macros |> 
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                wTemp) |> 
  distinct()

##add in the variables just selected
#sampleID is the "key" used to match up the two data frames
my.df <- left_join(macro.joined, variables) |> 
  
  #filter out anything you don't want
  #the example below would filter for just summer
  dplyr::filter(season == "Summer") |> 
  
    #pivot wider to make a column for each taxon
  pivot_wider(names_from = family, 
              values_from = c(density, relab),
              values_fill = 0)






```
```{r}
#| label: competition-long


##calculate the number of macros in each sampleID
macro.total <- macros |> 
  
  #calculate the number of macros in each sampleID
  group_by(sampleID, benthicArea) |> 
  summarize(total.macros = sum(number, na.rm = TRUE))



##calculate the number of each taxon of interest in each sampleID
macro.family <- macros |> 
  
  #join taxonomic information 
  left_join(master.taxa) |> 
  
  # Summarize for each sampleID and each family 
  # note you can exchange family with another taxonomic level of interest
  group_by(sampleID, family) |> 
  dplyr::summarise(number = sum(number, na.rm = TRUE)) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, family,
           fill = list(number = 0)) |> 
  
  #filter for families of interest
  #this needs to match what is in the macros file
  #replace thses blanks with the families you want to keep
  ## note you can exchange family with another taxonomic level of interest
  dplyr::filter(family == "Thremmatidae" | family == "Glossosomatidae")  



##join the two datasets
macro.joined  <- left_join(macro.total, macro.family) |> 
  
  #calc the relative abundance of each taxon
  # replace the blanks with the name of each taxon
  mutate(relab = number/total.macros,
         density = number/benthicArea)


## select other variables you want present in your final dataset
variables <- macros |> 
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                DO, mon.median.discharge, wTemp, mon.median.wTemp) |> 
  distinct()

##add in the variables just selected
#sampleID is the "key" used to match up the two data frames
my.df <- left_join(macro.joined, variables) |> 
  
  #filter out anything you don't want
  #the example below would filter out just the year 2018
  dplyr::filter(season == "Summer") 


ggplot(
data = my.df, #put the data frame name here

#set the aesthetics
aes(x = year,       #put the factor on the x-axis
    y = density,       #proportion values = y
    fill = family, color = family)) + #family (or other taxa) for fill & color
  
  #adds stacked bars
  geom_bar(position = "fill", stat = "identity") +
  
  #nicer labels (see axis.labels.R script)
  xlab("Year") +
  ylab("Relative Abundance\n") +

  #additional formatting
  coord_cartesian(ylim = c(0,1), expand = FALSE, clip = 'off') +
  theme_classic(base_size = 12)  +  #sets the font size
  theme(legend.position = "right") 


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.discharge,       #put the factor on the x-axis
      y = density +1)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(aes(color = year),size = 2, alpha = 0.6) +    #sets the size of the points
  
  #add best fit line
  geom_smooth(method = "lm", se = FALSE) + 

  #nicer labels (see axis.labels.R script)
  ylab(bquote("Density (number/"~m^2*")")) +
  xlab("Monthly Median Discharge (cfs)") +
  labs(color = "Year") + #label for the color key
  
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  
  facet_grid(cols = vars(family))   #place factor to split by facets here


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = wTemp,       #put the factor on the x-axis
      y = density +1)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(aes(color = year),size = 2, alpha = 0.6) +    #sets the size of the points
  
  #add best fit line
  geom_smooth(method = "lm", se = FALSE) + 

  #nicer labels (see axis.labels.R script)
  ylab(bquote("Density (number/"~m^2*")")) +
  xlab("Water Temperature ("~degree~"C)") +
  labs(color = "Year") + #label for the color key
  
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  
  facet_grid(cols = vars(family))   #place factor to split by facets here


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = DO,       #put the factor on the x-axis
      y = density +1)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(aes(color = year),size = 2, alpha = 0.6) +    #sets the size of the points
  
  #add best fit line
  geom_smooth(method = "lm", se = FALSE) + 

  #nicer labels (see axis.labels.R script)
  ylab(bquote("Density (number/"~m^2*")")) +
  xlab("Dissolved Oxygen (mg/L)") +
  labs(color = "Year") + #label for the color key
  
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  
  facet_grid(cols = vars(family))   #place factor to split by facets here

ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.wTemp,       #put the factor on the x-axis
      y = density +1)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(aes(color = year),size = 3, alpha = 0.6) +    #sets the size of the points
  
  #add best fit line
  geom_smooth(method = "lm", se = FALSE) + 
  

  #nicer labels (see axis.labels.R script)
  ylab(bquote("Density (number/"~m^2*")")) +
  xlab("Monthly Median Water Temperature") +
  labs(color = "Year") + #label for the color key
  
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  
  facet_grid(cols = vars(family))   #place factor to split by facets here


```

```{r}

#this code will make a dot plot with median and all points included
#make sure you have loaded the ggbeeswarm package to use geom_quasirandom()

ggplot(
  data = waterQ, #put the data frame name here
  
  #set the aesthetics
  aes(x = location,       #put the factor on the x-axis
      y = wTemp,       #continuous variable = y
      color = location)) + #same factor as x-axis for color
  
  #adds quasirandom jittered points
  geom_quasirandom(
    shape = 19,            #shape as circle
    size = 2,              #size of point
    alpha = 0.8,           #transparency
    width = 0.25) +        #spread
  
  #adds median
  stat_summary(
    fun = median,       #graphs the median
    geom = "crossbar",  #crossbar shape
    width = 0.5,        #width of the bar
    size = 0.75,        #size
    color = "black") +  #color 
  
  #nicer labels (see axis.labels.R script)
  #ylab("___") +
  #xlab("___") +
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "none")   #controls legend/key


#see the resources below for some additional options to make a nice plot 
# https://www.datanovia.com/en/lessons/ggplot-dot-plot/
# https://ggplot2.tidyverse.org/index.html


```

```{r}
# make sure the 'tidyverse' package is installed and loaded to run the code below
# macros, master.taxa, & env data must all be imported before you can run the code below


##calculate the number of macros in each sampleID
macro.total <- macros |> 
  
  #calculate the number of macros in each sampleID
  group_by(sampleID, benthicArea) |> 
  summarize(total.macros = sum(number, na.rm = TRUE))



##calculate the number of each FFG in each sampleID
macro.ffg <- macros |> 
  
  #join taxonomic information 
  left_join(master.taxa) |> 
  
  # Summarize for each sampleID and each FFG 
  # note you can exchange FFG with another taxonomic level of interest
  group_by(sampleID, FFG) |> 
  dplyr::summarise(number = sum(number, na.rm = TRUE)) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, FFG,
           fill = list(number = 0)) 

#filter for the organisms without FFGs assigned
macro.ffg.na <- macro.ffg |> 
  filter(is.na(FFG) & number > 0)

#add back the organisms without FFGs assigned
macro.ffg <- macro.ffg |> 
  filter(!is.na(FFG)) |> 
  bind_rows(macro.ffg.na)


##join the two datasets
macro.joined  <- left_join(macro.total, macro.ffg) |> 
  
  #calc the relative abundance of each taxon
  # replace the blanks with the name of each taxon
  mutate(relab = number/total.macros,
         density = number/benthicArea)


## select other variables you want present in your final dataset
variables <- macros |> 
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea,
                mon.median.discharge, mon.max.discharge, flow) |> 
  distinct()

##add in the variables just selected
#sampleID is the "key" used to match up the two data frames
my.df <- left_join(macro.joined, variables)  |> 
  
  #filter out anything you don't want
  #the example below would filter for just scrapers
  dplyr::filter(FFG == "cg" | FFG == "cf") 


#this code will make stacked bar graphs for 
#relative abundance of functional feeding groups

ggplot(
data = my.df, #put the data frame name here

#set the aesthetics
aes(x = year,       #put the factor on the x-axis
    y = density,       #proportion values = y
    fill = FFG, color = FFG)) + #functional feeding groups for fill & color
  
  #adds stacked bars
  geom_bar(position = "fill", stat = "identity") +
  

  #nicer labels (see axis.labels.R script)
  # xlab("___") +
  # ylab("Relative Abundance\n") +
  # scale_fill_discrete(
  #   name = "Functional Feeding Groups",
  #   labels = c("collector filterers", 
  #              "collector gatherers",
  #              "predators", 
  #              "scrapers", 
  #              "shredders" )) +
  
  #remove repeated key
  guides(color = FALSE) +
  
  #additional formatting
  coord_cartesian(ylim = c(0,1), expand = FALSE, clip = 'off') +
  theme_classic(base_size = 12)  +  #sets the font size
  theme(legend.position = "right") +  #controls legend/key

  #you can use the line below to split by factors
  #(season, year, location, or other factors)
  facet_grid(cols = vars(season)) 

#see the resources below for some additional options to make a nice plot 
# https://www.r-graph-gallery.com/48-grouped-barplot-with-ggplot2.html
# https://ggplot2.tidyverse.org/index.html
# https://r-charts.com/part-whole/stacked-bar-chart-ggplot2/



# this code will make a scatter plot with a curve
# 
ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = flow,       #put the factor on the x-axis
      y = relab)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(aes(color = year), size = 3) +    #sets the size of the points
  
  # #add locally weighted smoothing curve
  # geom_smooth(method = "loess",       
  #             se = FALSE, 
  #             formula = y ~ x) + 
  
    #add best fit line
  geom_smooth(method = "lm", se = FALSE) + 
  
  # #nicer labels (see axis.labels.R script)
  # ylab("___") +
  # xlab("___") +
  # labs(color = "___") + #label for the color key
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  
  facet_grid(rows = vars(FFG), cols = vars(season))


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = mon.median.discharge,       #put the factor on the x-axis
      y = relab)) + #put the same factor as on x-axis 
  
  #add points
  geom_point(aes(color = year), size = 3) +    #sets the size of the points

  #add locally weighted smoothing curve
  geom_smooth(method = "loess",
              se = FALSE,
              formula = y ~ x) +
  

  # #nicer labels (see axis.labels.R script)
  # ylab("___") +
  # xlab("___") +
  # labs(color = "___") + #label for the color key
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") +  #controls legend/key
  
  facet_grid(rows = vars(FFG), cols = vars(season))



ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = year,       #put the factor on the x-axis
      y = mon.median.discharge,       #continuous variable = y
      color = year)) + #same factor as x-axis for color
  
  #adds quasirandom jittered points
  geom_quasirandom(
    shape = 19,            #shape as circle
    size = 2,              #size of point
    alpha = 0.8,           #transparency
    width = 0.25) +        #spread
  
  #adds median
  stat_summary(
    fun = median,       #graphs the median
    geom = "crossbar",  #crossbar shape
    width = 0.5,        #width of the bar
    size = 0.75,        #size
    color = "black") +  #color 
  
  # #nicer labels (see axis.labels.R script)
  # ylab("___") +
  # xlab("___") +
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "none") +  #controls legend/key
  
  facet_grid(cols = vars(season))

```

```{r}
# make sure the 'tidyverse' package is installed and loaded to run the code below
# macros, master.taxa, & env data must all be imported before you can run the code below


##calculate the number of macros in each sampleID
macro.total <- macros |> 
  
  #calculate the number of macros in each sampleID
  group_by(sampleID, benthicArea) |> 
  summarize(total.macros = sum(number, na.rm = TRUE))



##calculate the number of each taxon of interest in each sampleID
macro.family <- macros |> 
  
  #join taxonomic information 
  left_join(master.taxa) |> 
  
  # Summarize for each sampleID and each family 
  # note you can exchange family with another taxonomic level of interest
  group_by(sampleID, family) |> 
  dplyr::summarise(number = sum(number, na.rm = TRUE)) |> 
  
  #fill in group combos where there were none present with zeros
  ungroup() |> 
  complete(sampleID, family,
           fill = list(number = 0)) |> 
  
  #filter for family of interest
  #this needs to match what is in the macros file
  #replace this blank with the family you want to keep
  ## note you can exchange family with another taxonomic level of interest
  dplyr::filter(family == "Elmidae" | family == "Heptageniidae" | family== "Ancylidae")  



##join the two datasets
macro.joined  <- left_join(macro.total, macro.family) |> 
  
  #calc the relative abundance of each taxon
  # replace the blanks with the name of each taxon
  mutate(relab = number/total.macros,
         density = number/benthicArea)


## select other variables you want present in your final dataset
variables <- macros |> 
  
  #join environmental variables
  left_join(env) |> 
  
  #select variables of interest
  #delete anything you don't need
  #add anything you do need in the blank with commas in between
  dplyr::select(date, sampleID, season, year, location, benthicArea) |> 
  distinct()

##add in the variables just selected
#sampleID is the "key" used to match up the two data frames
my.df <- left_join(macro.joined, variables) 
  
  #filter out anything you don't want
  #the example below would filter out just the year 2018
  #dplyr::filter(year != "2018") 


ggplot(
data = my.df, #put the data frame name here

#set the aesthetics
aes(x = year,       #put the factor on the x-axis
    y = density,       #proportion values = y
    fill = family, color = family)) + #functional feeding groups for fill & color
  
  #adds stacked bars
  geom_bar(position = "fill", stat = "identity") +
  

  #nicer labels (see axis.labels.R script)
  xlab("Year") +
  ylab("Relative Abundance\n") +
  # scale_fill_discrete(
  #   name = "Functional Feeding Groups",
  #   labels = c("collector filterers", 
  #              "collector gatherers",
  #              "predators", 
  #              "scrapers", 
  #              "shredders" )) +
  
  #remove repeated key
  guides(color = FALSE) +
  
  #additional formatting
  coord_cartesian(ylim = c(0,1), expand = FALSE, clip = 'off') +
  theme_classic(base_size = 12)  +  #sets the font size
  theme(legend.position = "right") +  #controls legend/key

  #you can use the line below to split by factors
  #(season, year, location, or other factors)
  facet_grid(rows = vars(season), cols = vars(location)) 



#this code will make a dot plot with median and all points included
#make sure you have loaded the ggbeeswarm package to use geom_quasirandom()


ggplot(
  data = my.df, #put the data frame name here
  
  #set the aesthetics
  aes(x = year,       #put 1st factor on x-axis
      y = density +1,       #continuous variable = y
      group = location, color = location)) + #2nd factor as group & color
  
  #adds quasirandom jittered points
  geom_quasirandom(
    shape = 19,            #shape as circle
    size = 2,              #size of point
    alpha = 0.8,           #transparency
    width = 0.25,          #spread
    dodge.width = 1,       #match with position_dodge(width = )
    show.legend = TRUE) +  #creates key
  
  #adds median
  stat_summary(
    fun = median,       #graphs the median
    geom = "crossbar",  #crossbar shape
    width = 0.5,        #width of the bar
    size = 0.75,        #size
    color = "black",    #color 
    position = position_dodge(width = 1), #match to dodge.width above
    show.legend = FALSE) +   #removes extra key
  
  # #nicer labels (see axis.labels.R script)
  # ylab("___") +
  # xlab("___") +
  # labs(color = "___") + #label for the color key
  
  #additional formatting
  theme_classic(base_size = 16)  +  #sets the font size
  theme(legend.position = "top") + #controls legend/key
  
  scale_y_log10() +     #changes y-axis to log-scale
  annotation_logticks(sides = "l") + # adds log-scale tick marks
  
  facet_grid(cols = vars(season), rows = vars(family))




#get median macro density for each year, season, location 
macden.sum <- my.df |> 
  group_by(year, season, location, family, sampleID) |> 
  summarize(density = sum(density)) |> 
  group_by(year, season, location, family) |> 
  summarize(median.density = median(density)) |> 
  na.omit()

#pivot wider then subtract locations
macden.diff <- macden.sum |> 
  pivot_wider(names_from = location, values_from = median.density) |> 
  mutate(median.dens.diff = (Downstream - Upstream))

macden.diff.fig <- macden.diff |> 
  ggplot(aes(
    x = year,
    y = median.dens.diff)) +
    geom_hline(yintercept = 0, color = "red", size = 2, alpha = 0.25) +
    geom_point(size = 3) +
    ylab("Median Difference in\n Macroinvertebrate Density (#/m\u00b2)\n (Downstream - Upstream)") +
    xlab("Year") +
    theme_classic(base_size = 14) +
    facet_grid(cols = vars(season), rows = vars(family)) +
    scale_y_continuous(breaks = c(-10^(4:0), 0, 10^(0:4)),
                       transform = "pseudo_log",
                       limits = c(-4000, 4000)) +
    guides(y = guide_axis_logticks(negative_small = 1)) +
    geom_vline(xintercept=2.5, color = "blue", size = 2, alpha = 0.25)

macden.diff.fig



#get median macro relative abundance for each year, season, location 
mac.sum <- my.df |> 
  group_by(year, season, location, family, sampleID) |> 
  summarize(relab = median(relab)) |> 
  group_by(year, season, location, family) |> 
  summarize(median.rel = median(relab)) |> 
  na.omit()

#pivot wider then subtract locations
mac.diff <- mac.sum |> 
  pivot_wider(names_from = location, values_from = median.rel) |> 
  mutate(median.rel.diff = (Downstream - Upstream))

mac.diff |> 
  ggplot(aes(
    x = year,
    y = median.rel.diff)) +
    geom_hline(yintercept = 0, color = "red", size = 2, alpha = 0.25) +
    geom_point(size = 3) +
    ylab("Median Difference in Relative Abundance\n (Downstream - Upstream)") +
    xlab("Year") +
    theme_classic(base_size = 14) +
    facet_grid(cols = vars(season), rows = vars(family)) +
    # scale_y_continuous(breaks = c(-10^(4:0), 0, 10^(0:4)),
    #                    transform = "pseudo_log",
    #                    limits = c(-4000, 4000)) +
    # guides(y = guide_axis_logticks(negative_small = 1)) +
    geom_vline(xintercept=2.5, color = "blue", size = 2, alpha = 0.25)




```

